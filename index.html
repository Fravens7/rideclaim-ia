<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rideclaim - M1 division</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <!-- Tesseract.js para OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

    <!--chart.js para graficos-->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  

    <!-- <div id="detailsModal" class="modal">...</div> -->

<!-- NUEVA MODAL PARA EL GR√ÅFICO -->
<div id="chartModal" class="modal">
    <div class="modal-content" style="max-width: 900px;">
        <span class="close" id="closeChartBtn">&times;</span>
        <h2>M1 Calendar Analysis</h2>
        <div style="position: relative; width: 100%; overflow-x: auto;">
            <div id="tripCalendar"></div>
        </div>
        <div id="calendarLegend" style="display: flex; justify-content: center; margin-top: 15px;">
            <div style="display: flex; align-items: center; margin-right: 20px;">
                <div style="width: 20px; height: 20px; background-color: #28a745; margin-right: 8px;"></div>
                <span>Home to Office</span>
            </div>
            <div style="display: flex; align-items: center; margin-right: 20px;">
                <div style="width: 20px; height: 20px; background-color: #007bff; margin-right: 8px;"></div>
                <span>Office to Home</span>
            </div>
            <div style="display: flex; align-items: center;">
                <div style="width: 20px; height: 20px; background-color: #f8f9fa; border: 1px solid #ddd; margin-right: 8px;"></div>
                <span>No Trip</span>
            </div>
        </div>
    </div>
</div>

    
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            display: flex;
            align-items: flex-start;
        }
        .logo-container {
            margin-right: 30px;
            flex-shrink: 0;
        }
        .logo-container img {
            max-width: 120px;
            height: auto;
        }
        .main-content {
            flex: 1;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f1f1f1;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s;
        }
        .upload-area:hover {
            border-color: #007bff;
            background-color: #f8f9fa;
        }
        .upload-area.dragover {
            border-color: #007bff;
            background-color: #e9f7fe;
        }
        input[type="file"] {
            display: none;
        }
        .upload-label {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .upload-label:hover {
            background-color: #0056b3;
        }
        .file-list {
            margin-top: 20px;
            display: none;
        }
        .file-item {
            display: flex;
            flex-direction: column;
            padding: 15px;
            margin-bottom: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 5px solid #ccc;
        }
        .file-item.processing {
            background-color: #e9f7fe;
            border-left-color: #007bff;
        }
        .file-item.success {
            background-color: #d4edda;
            border-left-color: #28a745;
        }
        .file-item.error {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        .file-item.invalid {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }
        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-name {
            font-weight: bold;
            flex-grow: 1;
        }
        .file-status {
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .status-processing {
            background-color: #cce5ff;
            color: #004085;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
        }
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status-invalid {
            background-color: #fff3cd;
            color: #856404;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s;
        }
        .map-container {
            height: 400px;
            margin-top: 20px;
            border-radius: 10px;
            border: 1px solid #ddd;
            display: none;
        }
        .map-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .results-container {
            margin-top: 30px;
            display: none;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .results-table th, .results-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .results-table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .results-table tr:hover {
            background-color: #f5f5f5;
        }
        .view-details-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .view-details-btn:hover {
            background-color: #0056b3;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 700px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .extracted-text {
            margin-top: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .clear-btn {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .clear-btn:hover {
            background-color: #c82333;
        }
        .summary {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9f7fe;
            border-radius: 5px;
            text-align: right;
            font-weight: bold;
        }
        .valid-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }
        .valid-badge.valid {
            background-color: #d4edda;
            color: #155724;
        }
        .valid-badge.invalid {
            background-color: #f8d7da;
            color: #721c24;
        }
        .valid-badge.incomplete {
            background-color: #fff3cd;
            color: #856404;
        }
        .validation-details {
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }
        .image-preview {
            max-width: 200px;
            max-height: 150px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .file-details {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
        }
        .api-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: center;
        }
        .api-status.success {
            background-color: #d4edda;
            color: #155724;
        }
        .api-status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .api-status.processing {
            background-color: #cce5ff;
            color: #004085;
        }
        
        /* Estilos para el calendario */
        .calendar-table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        .calendar-table th, .calendar-table td {
            border: 1px solid #ddd;
            text-align: center;
            padding: 8px;
            width: 14.28%; /* 7 columnas */
        }
        .calendar-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .calendar-table .day-number {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .trip-indicator {
            width: 14px; /* Tama√±o ajustado */
            height: 14px; /* Tama√±o ajustado */
            display: inline-block;
            margin: 2px;
            border-radius: 2px;
            cursor: pointer;
        }
        .home-to-office {
            background-color: #28a745;
        }
        .office-to-home {
            background-color: #007bff;
        }
        .no-trip {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
        }
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .calendar-nav {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .calendar-nav:hover {
            background-color: #0056b3;
        }
        
        /* Estilos para el tooltip */
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="logo-container">
        <img src="logo.png" alt="Rideclaim Logo">
    </div>
    
    <div class="main-content">
        <div class="container">
            <h1>Rideclaim - M1 division</h1>
            
            <div class="tabs">
                <div class="tab" id="pdf-tab">PDF</div>
                <div class="tab active" id="image-tab">Image</div>
            </div>
            
            <div id="pdf-content" class="tab-content">
                <div class="upload-area" id="pdfUploadArea">
                    <label for="pdfFiles" class="upload-label">Select PDFs</label>
                    <p>or drag and drop files here</p>
                    <input type="file" id="pdfFiles" accept="application/pdf" multiple>
                </div>
                <div class="file-list" id="pdfFileList"></div>
            </div>
            
            <div id="image-content" class="tab-content active">
                <div class="upload-area" id="imageUploadArea">
                    <label for="imageFiles" class="upload-label">Select Images</label>
                    <p>or drag and drop files here (PNG, JPG)</p>
                    <input type="file" id="imageFiles" accept="image/png, image/jpeg, image/jpg" multiple>
                </div>
                <div class="file-list" id="imageFileList"></div>
                <div id="apiStatus" class="api-status" style="display: none;"></div>
            </div>
            
            <div id="map-container" class="map-container"></div>
            
            <div class="results-container" id="resultsContainer">
                <h2>Results</h2>
                <table class="results-table" id="resultsTable">
                    <thead>
                        <tr>
                            <th>File</th>
                            <th>Type</th>
                            <th>Origin</th>
                            <th>Destination</th>
                            <th>Total LKR</th>
                            <th>Validation</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="resultsBody"></tbody>
                </table>
                <div class="summary" id="summary"></div>
                <button class="clear-btn" id="clearBtn">Clear results</button>
                <button class="clear-btn" id="viewChartBtn" style="background-color: #17a2b8; margin-left: 10px;">View Trip Chart</button>
            </div>
        </div>
    </div>

    <div id="detailsModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>File Details</h2>
            <div class="extracted-text" id="modalExtractedText"></div>
        </div>
    </div>

    <!-- Tooltip para mostrar la hora del viaje -->
    <div id="tooltip" class="tooltip"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        const staticLocations = {
            home: { lat: 6.89535, lng: 79.85766 }, office: { lat: 6.882986650923001, lng: 79.86809890134177 }
        };

        const zoneKeywords = {
            home: ['43b', '43d', 'lauries'],
            office: ['mireka', 'havelock', '324']
        };

        function findZone(addressText) {
    if (!addressText) return null;
    const lowerCaseText = addressText.toLowerCase();

    for (const zoneName in zoneKeywords) {
        const keywords = zoneKeywords[zoneName];
        const isThisZone = keywords.some(keyword => lowerCaseText.includes(keyword));
        if (isThisZone) {
            return zoneName; // Devuelve 'home' o 'office'
        }
    }

    return null; // No se encontr√≥ ninguna zona coincidente
}
        
        const pdfTab = document.getElementById('pdf-tab'); const imageTab = document.getElementById('image-tab');
        const pdfContent = document.getElementById('pdf-content'); const imageContent = document.getElementById('image-content');
        const pdfUploadArea = document.getElementById('pdfUploadArea'); const imageUploadArea = document.getElementById('imageUploadArea');
        const pdfFiles = document.getElementById('pdfFiles'); const imageFiles = document.getElementById('imageFiles');
        const pdfFileList = document.getElementById('pdfFileList'); const imageFileList = document.getElementById('imageFileList');
        const resultsContainer = document.getElementById('resultsContainer'); const resultsBody = document.getElementById('resultsBody');
        const summary = document.getElementById('summary'); const clearBtn = document.getElementById('clearBtn'); const mapContainer = document.getElementById('map-container');
        const modal = document.getElementById('detailsModal'); const modalExtractedText = document.getElementById('modalExtractedText');
        const closeBtn = document.querySelector('#detailsModal .close');
        const apiStatus = document.getElementById('apiStatus');
        const tooltip = document.getElementById('tooltip');
        
        let fileResults = [];
        let map = null;
        let processedPdfNames = new Set(); //memory for pdf
        let processedImageNames = new Set(); //memory for png or images

        pdfTab.addEventListener('click', () => { pdfTab.classList.add('active'); imageTab.classList.remove('active'); pdfContent.classList.add('active'); imageContent.classList.remove('active'); });
        imageTab.addEventListener('click', () => { imageTab.classList.add('active'); pdfTab.classList.remove('active'); imageContent.classList.add('active'); pdfContent.classList.remove('active'); });
        
        pdfFiles.addEventListener('change', handlePdfFileSelect);
        pdfUploadArea.addEventListener('dragover', (e) => { e.preventDefault(); pdfUploadArea.classList.add('dragover'); });
        pdfUploadArea.addEventListener('dragleave', () => { pdfUploadArea.classList.remove('dragover'); });
        pdfUploadArea.addEventListener('drop', (e) => { e.preventDefault(); pdfUploadArea.classList.remove('dragover'); if (e.dataTransfer.files.length) handlePdfFiles(e.dataTransfer.files); });

        imageFiles.addEventListener('change', handleImageFileSelect);
        imageUploadArea.addEventListener('dragover', (e) => { e.preventDefault(); imageUploadArea.classList.add('dragover'); });
        imageUploadArea.addEventListener('dragleave', () => { imageUploadArea.classList.remove('dragover'); });
        imageUploadArea.addEventListener('drop', (e) => { e.preventDefault(); imageUploadArea.classList.remove('dragover'); if (e.dataTransfer.files.length) handleImageFiles(e.dataTransfer.files); });
        
        closeBtn.onclick = () => modal.style.display = 'none';
        window.onclick = (event) => { if (event.target == modal) modal.style.display = 'none'; };
clearBtn.addEventListener('click', () => {
    fileResults = [];
    pdfFileList.innerHTML = ''; 
    pdfFileList.style.display = 'none';
    imageFileList.innerHTML = ''; 
    imageFileList.style.display = 'none';
    resultsContainer.style.display = 'none'; 
    resultsBody.innerHTML = ''; 
    summary.innerHTML = '';
    mapContainer.innerHTML = ''; 
    if (map) { 
      map.remove(); 
      map = null; 
    }
    
    apiStatus.style.display = 'none';      
    processedPdfNames.clear();      //clean pdf memory
    processedImageNames.clear();   //clean image or png memory           
}); // <-- AHORA ESTA LLAVE CIERRA CORRECTAMENTE LA FUNCI√ìN DEL `addEventListener`

        
        
              
        
        
        
        
function handlePdfFiles(files) {
    const pdfFilesArr = Array.from(files).filter(file => file.type === 'application/pdf');
    if (pdfFilesArr.length === 0) {
        alert('Please select at least one valid PDF file.');
        return;
    }
    pdfFileList.style.display = 'block';
    pdfFileList.innerHTML = '';
    
    pdfFilesArr.forEach(file => {
        // --- PASO 1: Revisar si ya fue procesado ---
        if (processedPdfNames.has(file.name)) {
            const duplicateItem = createDuplicateFileItem(file, 'pdf');
            pdfFileList.appendChild(duplicateItem);
            return; // Detener el procesamiento para este archivo
        }
        
        // --- PASO 2: ¬°A√ëADIR EL NOMBRE A LA MEMORIA! ---
        // Esta es la l√≠nea clave que probablemente te falta o est√° en el lugar equivocado.
        processedPdfNames.add(file.name);

        // --- PASO 3: Procesar el archivo como nuevo ---
        const fileItem = createFileItem(file, 'pdf');
        pdfFileList.appendChild(fileItem);
        processPdfFile(file, fileItem);
    });
}
        
        
        
        /**
 * --- FUNCI√ìN AUXILIAR: Crea un elemento visual para archivos duplicados ---
 */
function createDuplicateFileItem(file, type) {
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item invalid'; // Usa el estilo 'invalid' (amarillo)
    fileItem.id = `file-${type}-${file.name.replace(/\s/g, '-')}`;

    const fileHeader = document.createElement('div');
    fileHeader.className = 'file-header';

    const fileName = document.createElement('div');
    fileName.className = 'file-name';
    fileName.textContent = file.name;

    const fileStatus = document.createElement('div');
    fileStatus.className = 'file-status status-invalid';
    fileStatus.textContent = 'Duplicate file ignored';

    fileHeader.appendChild(fileName);
    fileHeader.appendChild(fileStatus);
    fileItem.appendChild(fileHeader);

    return fileItem;}
        
        
        
        
        
        
        
    function processPdfFile(file, fileItem) { const fileReader = new FileReader(); fileReader.onload = function() { const typedarray = new Uint8Array(this.result); pdfjsLib.getDocument(typedarray).promise.then(function(pdf) { let totalPages = pdf.numPages; let fullText = ''; let pagePromises = []; for (let i = 1; i <= totalPages; i++) { pagePromises.push(pdf.getPage(i).then(function(page) { return page.getTextContent().then(function(textContent) { let pageText = ''; textContent.items.forEach(function(item) { pageText += item.str + ' '; }); return pageText; }); })); } Promise.all(pagePromises).then(function(pageTexts) { pageTexts.forEach(function(text) { fullText += text + '\n'; }); const tripInfo = extractTripInfoFromPdf(fullText); processExtractedText(file, fileItem, fullText, 'pdf', tripInfo); }); }).catch(function(error) { console.error('Error processing PDF:', error); fileItem.className = 'file-item error'; const fileStatus = fileItem.querySelector('.file-status'); fileStatus.className = 'file-status status-error'; fileStatus.textContent = 'Error processing'; mapContainer.style.display = 'none'; }); }; fileReader.readAsArrayBuffer(file); }
        
        
        
        
        
        
        
        
        
        function extractTripInfoFromPdf(text) { 
            let origin = null; 
            let destination = null; 
            let tripTime = null;
            
            const timePattern = /(\d{1,2}:\d{2})\s+([a-zA-Z0-9\s,]+Sri Lanka)/g; 
            let match; 
            const addresses = []; 
            while ((match = timePattern.exec(text)) !== null) { 
                addresses.push({ time: match[1], address: match[2].trim() }); 
            } 
            
            if (addresses.length >= 2) { 
                origin = addresses[0].address; 
                destination = addresses[1].address; 
                tripTime = addresses[0].time;
            } else { 
                const addressPattern = /([a-zA-Z0-9\s,]+Sri Lanka)/g; 
                const allAddresses = []; 
                while ((match = addressPattern.exec(text)) !== null) { 
                    allAddresses.push(match[1].trim()); 
                } 
                if (allAddresses.length >= 2) { 
                    origin = allAddresses[0]; 
                    destination = allAddresses[1]; 
                } 
            } 
            return { origin, destination, tripTime }; 
        }

        // --- L√ìGICA IMAGEN (MODIFICADA) ---
        function handleImageFileSelect(e) { if (e.target.files.length) handleImageFiles(e.target.files); }

        //supuestamente falta esto
        function handlePdfFileSelect(e) { if (e.target.files.length) handlePdfFiles(e.target.files); }

        //function handleImageFiles(files) { const imageFilesArr = Array.from(files).filter(file => /image\/(png|jpeg|jpg)/.test(file.type)); if (imageFilesArr.length === 0) { alert('Please select at least one valid image file (PNG, JPG).'); return; } imageFileList.style.display = 'block'; imageFileList.innerHTML = ''; imageFilesArr.forEach(file => { const fileItem = createFileItem(file, 'image'); imageFileList.appendChild(fileItem); processImageFile(file, fileItem); }); }
        function handleImageFiles(files) {
    const imageFilesArr = Array.from(files).filter(file => /image\/(png|jpeg|jpg)/.test(file.type));
    if (imageFilesArr.length === 0) {
        alert('Please select at least one valid image file (PNG, JPG).');
        return;
    }
    imageFileList.style.display = 'block';
    imageFileList.innerHTML = '';
    
    imageFilesArr.forEach(file => {
        // --- INICIO DEL LIMPIADOR DE DUPLICADOS ---
        if (processedImageNames.has(file.name)) {
            // Si la imagen ya fue procesada, la ignora y muestra un aviso
            const duplicateItem = createDuplicateFileItem(file, 'image');
            imageFileList.appendChild(duplicateItem);
            return; // Detiene el procesamiento para este archivo
        }
        
        // --- CAMBIO CLAVE: A√ëADIMOS EL NOMBRE A LA MEMORIA ---
        processedImageNames.add(file.name);
        // --- FIN DEL CAMBIO ---

        const fileItem = createFileItem(file, 'image');
        imageFileList.appendChild(fileItem);
        processImageFile(file, fileItem);
    });
}






        function processImageFile(file, fileItem) {
            const fileReader = new FileReader();
            fileReader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const processedImgSrc = preprocessImage(img);
                    
                    const progressBar = fileItem.querySelector('.progress'); const fileStatus = fileItem.querySelector('.file-status');
                    Tesseract.recognize(processedImgSrc, 'eng', { logger: m => { if (m.status === 'recognizing text') { const progress = Math.round(m.progress * 100); progressBar.style.width = `${progress}%`; fileStatus.textContent = `Processing... ${progress}%`; } } })
                    .then(({ data: { text } }) => {
                        console.log("Raw OCR Text:", text);
                        
                        // --- NUEVO: Usar LLM para estructurar los datos ---
                        // Mostrar estado de procesamiento de la API
                        apiStatus.style.display = 'block';
                        apiStatus.className = 'api-status processing';
                        apiStatus.textContent = 'Processing with AI...';
                        
                        extractTripsWithLLM(text)
                            .then(trips => {
                                console.log("Structured Data from LLM:", trips);
                                
                                // Ocultar estado de procesamiento
                                apiStatus.style.display = 'none';
                                
                                const fileDetails = document.createElement('div'); fileDetails.className = 'file-details'; fileDetails.textContent = `${trips.length} trip(s) found.`; fileItem.appendChild(fileDetails);
                                let validTripsFound = 0;
                                trips.forEach(trip => {
                                    const validationResult = validateTrip(trip, 'image');
                                    if (validationResult.isValid) validTripsFound++;
                                    fileResults.push({ 
                                        name: file.name, 
                                        type: 'image', 
                                        total: trip.total_lkr, 
                                        origin: trip.origin || 'Not specified', 
                                        destination: trip.destination, 
                                        isValid: validationResult.isValid, 
                                        validationDetails: validationResult.details, 
                                        text: text,
                                        tripTime: trip.trip_time || null
                                        // NO se a√±ade tripDate para im√°genes
                                    });
                                });
                                fileItem.className = validTripsFound > 0 ? 'file-item success' : 'file-item invalid';
                                fileStatus.className = `file-status ${validTripsFound > 0 ? 'status-success' : 'status-invalid'}`;
                                fileStatus.textContent = `Completed (${validTripsFound} valid)`;
                                progressBar.style.display = 'none';
                                updateResultsTable();
                            })
                            .catch(error => {
                                console.error('Error processing with LLM:', error);
                                
                                // Mostrar estado de error
                                apiStatus.className = 'api-status error';
                                apiStatus.textContent = `Error processing with AI: ${error.message}`;
                                
                                fileItem.className = 'file-item error';
                                fileStatus.className = 'file-status status-error';
                                fileStatus.textContent = 'Error processing with AI';
                                progressBar.style.display = 'none';
                            });
                    }).catch(err => { console.error('Error processing image:', err); fileItem.className = 'file-item error'; fileStatus.className = 'file-status status-error'; fileStatus.textContent = 'Error processing'; progressBar.style.display = 'none'; });
                };
                img.src = e.target.result;
            };
            fileReader.readAsDataURL(file);
        }
        
        function preprocessImage(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width; canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                const threshold = 150;
                const value = gray > threshold ? 255 : 0;
                data[i] = value; data[i + 1] = value; data[i + 2] = value;
            }
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL();
        }
        
        /**
 * --- VERSI√ìN MEJORADA: Funci√≥n para llamar a la API de Groq ---
 * Esta versi√≥n es m√°s robusta y a√±ade mensajes de depuraci√≥n.
 */
/**
/**
 * --- VERSI√ìN H√çBRIDA DEFINITIVA: Parser JS + LLM Fallback ---
 * Primero usa l√≥gica dura y determinista. La IA es solo un respaldo.
 */
async function extractTripsWithLLM(ocrText) {
    console.log("üöÄ Iniciando Parser H√≠brido...");

    // --- PASO 1: PARSER DETERMINISTA DE JAVASCRIPT ---
    const jsTrips = parseTripsWithJS(ocrText);

    if (jsTrips.length > 0) {
        console.log(`‚úÖ Parser JS encontr√≥ ${jsTrips.length} viajes. No se necesita la IA.`);
        return jsTrips;
    }

    // --- PASO 2: FALLBACK A LA IA (si el parser JS fall√≥) ---
    console.log("‚ö†Ô∏è El parser JS no encontr√≥ viajes. Activando fallback a la IA...");
    return await parseTripsWithLLM(ocrText);
}

/**
 * --- NUEVA FUNCI√ìN: LIMPIADOR DE NOMBRES DE DESTINO ---
 * Usa una lista blanca para limpiar los nombres extra√≠dos por el OCR.
 */
function cleanDestinationName(rawDestination) {
    if (!rawDestination) return '';

    const cleanedText = rawDestination.toLowerCase().trim();

    // Lista blanca de destinos conocidos y sus nombres limpios
    const knownDestinations = {
        'mireka tower': 'Mireka Tower',
        '43b lauries rd': '43b Lauries Rd',
        '43d lauries rd': '43d Lauries Rd',
        'colombo 00400': 'Colombo 00400',
        'seylan bank': 'Seylan Bank',
        'ar exotics': 'AR Exotics Marine',
        'get u fit': 'Get U Fit Gym',
        'keells': 'Keells - Lauries',
        'jungle juice': 'Jungle Juice Bar'
    };

    // Busca si el texto sucio contiene alguno de nuestros destinos conocidos
    for (const keyword in knownDestinations) {
        if (cleanedText.includes(keyword)) {
            return knownDestinations[keyword];
        }
    }

    // Si no se encuentra en la lista blanca, devuelve el texto original.
    // La validaci√≥n posterior se encargar√° de marcarlo como inv√°lido.
    console.warn(`‚ö†Ô∏è No se pudo limpiar el destino: "${rawDestination}"`);
    return rawDestination.trim();
}

/**
 * --- FUNCI√ìN AUXILIAR: El parser de JavaScript ---
 * Usa regex para encontrar precios y luego lee hacia atr√°s para encontrar el destino.
 */
/**
 * --- FUNCI√ìN AUXILIAR: El parser de JavaScript (Versi√≥n 2.0 con Detecci√≥n de Incompletos) ---
 * Usa regex para encontrar precios y luego lee hacia atr√°s para encontrar el destino.
 * A√ëADIDO: Un segundo pase para encontrar recibos incompletos que tienen "Rebook" pero no precio.
 */
function parseTripsWithJS(text) {
    const trips = [];
    const lines = text.split('\n');
    const priceRegex = /LKR\s*([0-9QOA.]+)/i;
    const timeRegex = /(\d{1,2}:\d{2}\s*(?:am|pm)?)/i;
    const dateRegex = /\b(\d{1,2}\s+\w{3})\b/i; // Ej: "3 oct"
    const rebookRegex = /rebook/i; // NUEVO: Regex para encontrar "Rebook"

    const priceLineIndices = [];
    lines.forEach((line, index) => {
        if (priceRegex.test(line)) {
            priceLineIndices.push(index);
        }
    });

    const relevantPriceLines = priceLineIndices.slice(0, 8);

    // --- PRIMER PASO: Procesar todos los viajes COMPLETOS (l√≥gica original) ---
    for (let i = 0; i < relevantPriceLines.length; i++) {
        const priceLineIndex = relevantPriceLines[i];
        const priceLine = lines[priceLineIndex];
        
        const priceMatch = priceLine.match(priceRegex);
        let total_lkr = priceMatch[1].replace(/Q|O/g, '0').replace(/A/g, '4');

        let status = 'valid';
        if (priceLine.toLowerCase().includes('canceled')) {
            status = 'valid'; // O 'canceled' si prefieres
        } else if (priceLine.toLowerCase().includes('view store')) {
            status = 'invalid';
        }

        let destination = '';
        let tripTime = null;
        let tripDate = null;
        
        // Extraer la fecha del viaje
        for (let j = priceLineIndex - 5; j <= priceLineIndex + 5; j++) {
            if (j >= 0 && j < lines.length) {
                const dateMatch = lines[j].match(dateRegex);
                if (dateMatch) {
                    tripDate = dateMatch[1];
                    break;
                }
            }
        }

        // Extraer la hora del viaje
        for (let j = priceLineIndex - 5; j <= priceLineIndex + 5; j++) {
            if (j >= 0 && j < lines.length) {
                const timeMatch = lines[j].match(timeRegex);
                if (timeMatch) {
                    tripTime = timeMatch[1];
                    break;
                }
            }
        }
        
        for (let j = priceLineIndex - 1; j >= 0; j--) {
            const lineAbove = lines[j].trim();
            if (priceRegex.test(lineAbove) || lineAbove.toLowerCase().includes('activity')) {
                break;
            }
            if (/\d{1,2}:\d{2}|^[~¬©¬¢&]/.test(lineAbove) || lineAbove.length < 2) {
                continue;
            }
            destination = lineAbove + ' ' + destination;
        }
        
        const cleanDestination = cleanDestinationName(destination);
        
        if (cleanDestination) {
            trips.push({ destination: cleanDestination, total_lkr, status, trip_time: tripTime, trip_date: tripDate });
        }
    }

    // --- NUEVO: SEGUNDO PASO para RECIBOS INCOMPLETOS ---
    // Ahora buscamos l√≠neas con "Rebook" que no est√©n cerca de un precio.
    
    // Guardamos los rangos de l√≠neas ya procesadas para no repetir
    const processedRanges = priceLineIndices.map(index => ({ start: index - 5, end: index + 5 }));

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // Si la l√≠nea no contiene "Rebook", la ignoramos
        if (!rebookRegex.test(line)) {
            continue;
        }

        // Si esta l√≠nea "Rebook" ya est√° cerca de una l√≠nea de precio que procesamos, la ignoramos
        const isAlreadyProcessed = processedRanges.some(range => i >= range.start && i <= range.end);
        if (isAlreadyProcessed) {
            continue;
        }

        // Si llegamos aqu√≠, encontramos un "Rebook" incompleto. Intentamos extraer sus datos.
        console.log(`üîç [INCOMPLETE] Encontrado posible recibo incompleto en la l√≠nea ${i}: "${line}"`);

        let destination = '';
        let tripTime = null;
        let tripDate = null;

        // Extraer destino (buscando hacia atr√°s desde "Rebook")
        for (let j = i - 1; j >= 0; j--) {
            const lineAbove = lines[j].trim();
            if (rebookRegex.test(lineAbove) || lineAbove.toLowerCase().includes('activity')) {
                break;
            }
            if (/\d{1,2}:\d{2}|^[~¬©¬¢&]/.test(lineAbove) || lineAbove.length < 2) {
                continue;
            }
            destination = lineAbove + ' ' + destination;
        }

        // Extraer fecha (buscando alrededor de "Rebook")
        for (let j = i - 5; j <= i + 5; j++) {
            if (j >= 0 && j < lines.length) {
                const dateMatch = lines[j].match(dateRegex);
                if (dateMatch) {
                    tripDate = dateMatch[1];
                    break;
                }
            }
        }

        // Extraer hora (buscando alrededor de "Rebook")
        for (let j = i - 5; j <= i + 5; j++) {
            if (j >= 0 && j < lines.length) {
                const timeMatch = lines[j].match(timeRegex);
                if (timeMatch) {
                    tripTime = timeMatch[1];
                    break;
                }
            }
        }

        const cleanDestination = cleanDestinationName(destination);

        if (cleanDestination) {
            // Creamos el objeto del viaje con estado 'incomplete'
            trips.push({ 
                destination: cleanDestination, 
                total_lkr: null, // Sin precio
                status: 'incomplete', // NUEVO ESTADO
                trip_time: tripTime, 
                trip_date: tripDate 
            });
        }
    }

    return trips;
}








/**
 * --- FUNCI√ìN AUXILIAR: El fallback a la IA (simplificado) ---
 * Solo se llama si el parser JS fall√≥.
 */
async function parseTripsWithLLM(ocrText) {
    // Usamos el prompt "few-shot" que ya funcionaba bien
    const prompt = `
Extract trip data from the following text. Return a JSON array of strings, each in format: "destination|total_lkr|status|trip_time".
Max 8 trips.
Example: ["Mireka Tower|250.00|valid|10:30am"]

Text:
"""
 ${ocrText}
"""
`;

    try {
        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
        });

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}`);
        }

        const data = await response.json();
        if (data.error) {
            throw new Error(data.error);
        }

        const llmResponse = data.message;
        console.log("--- Respuesta del Fallback a la IA ---");
        console.log(llmResponse);

        let tripsData = [];
        try {
            const stringArray = JSON.parse(llmResponse);
            if (Array.isArray(stringArray)) {
                for (const tripString of stringArray) {
                    const parts = tripString.split('|');
                    if (parts.length >= 3) {
                        tripsData.push({
                            destination: parts[0].trim(),
                            total_lkr: parts[1].trim(),
                            status: parts[2].trim(),
                            trip_time: parts[3] ? parts[3].trim() : null
                        });
                    }
                }
            }
        } catch (e) {
            console.error("‚ùå El fallback de la IA tambi√©n fall√≥.");
            throw new Error('Both JS parser and LLM fallback failed.');
        }
        
        return tripsData;

    } catch (error) {
        console.error('Error en el fallback a la IA:', error);
        throw error;
    }
}
        // --- L√ìGICA COMPARTIDA (con ajustes menores) ---
        function createFileItem(file, type) { 
            const fileItem = document.createElement('div'); 
            fileItem.className = 'file-item processing'; 
            fileItem.id = `file-${type}-${file.name.replace(/\s/g, '-')}`; 
            const fileHeader = document.createElement('div'); fileHeader.className = 'file-header'; 
            const fileName = document.createElement('div'); fileName.className = 'file-name'; fileName.textContent = file.name; 
            const fileStatus = document.createElement('div'); fileStatus.className = 'file-status status-processing'; fileStatus.textContent = 'Processing...'; 
            fileHeader.appendChild(fileName); fileHeader.appendChild(fileStatus); fileItem.appendChild(fileHeader); 
            const progressBar = document.createElement('div'); progressBar.className = 'progress-bar'; 
            const progress = document.createElement('div'); progress.className = 'progress'; progressBar.appendChild(progress); fileItem.appendChild(progressBar); 
            if (type === 'image') { const imgPreview = document.createElement('img'); imgPreview.className = 'image-preview'; imgPreview.src = URL.createObjectURL(file); fileItem.appendChild(imgPreview); } 
            return fileItem; 
        }
        
        function processExtractedText(file, fileItem, text, type, tripInfo) {
            // --- INTENTO 1: L√≥gica principal para el formato com√∫n ---
            let totalMatch = text.match(/Total\s+([\d,.]+)\s+LKR/i);
            // --- INTENTO 2: Respaldo para formatos inusuales (solo si el primero falla) --
            if(!totalMatch){
                totalMatch = text.match(/Total\s+LKR\s*([\d,.]+)/i);
            }
            const total = totalMatch ? totalMatch[1] : null;
            const validationResult = validateTrip(tripInfo, type);
            const fileStatus = fileItem.querySelector('.file-status');
            const progressBar = fileItem.querySelector('.progress-bar');
            if (progressBar) progressBar.style.display = 'none';
            if (total) {
                const fileTotal = document.createElement('div'); fileTotal.className = 'file-total'; fileTotal.textContent = `${total} LKR`; fileItem.appendChild(fileTotal);
                if (validationResult.isValid) { fileItem.className = 'file-item success'; fileStatus.className = 'file-status status-success'; fileStatus.textContent = 'Valid'; if (type === 'pdf' && validationResult.direction) displayMap(file.name, validationResult.direction); } 
                else { fileItem.className = 'file-item invalid'; fileStatus.className = 'file-status status-invalid'; fileStatus.textContent = 'Invalid'; mapContainer.style.display = 'none'; }
            } else { fileItem.className = 'file-item error'; fileStatus.className = 'file-status status-error'; fileStatus.textContent = 'Error: Total not found'; mapContainer.style.display = 'none'; }
            
            
            
            // ... dentro de processExtractedText ...

// --- NUEVO: Extraer la fecha del viaje ---
const dateMatch = text.match(/\b(\d{1,2}\s+\w{3})\b/i); // Busca "1 oct", "2 nov", etc.
const tripDate = dateMatch ? dateMatch[1] : 'Unknown Date';

fileResults.push({ 
    name: file.name, 
    type: type, 
    total: total, 
    origin: tripInfo.origin || 'Not specified', 
    destination: tripInfo.destination || 'Not specified', 
    isValid: validationResult.isValid, 
    validationDetails: validationResult.details, 
    text: text,
    tripDate: tripDate,
    direction: validationResult.direction, // <-- A√ëADE LA FECHA AL OBJETO
    tripTime: tripInfo.tripTime // <-- A√ëADE LA HORA AL OBJETO
});

updateResultsTable();
            
// // ... al final de la funci√≥n updateResultsTable() ...
// summary.innerHTML = `<p>Total files processed: 
//     ${fileResults.length}</p><p>Valid trips: 
//     ${validCount}</p><p>Invalid trips:
//     ${invalidCount}</p><p>Total LKR sum (valid trips):
//     ${totalSum.toFixed(2)} LKR</p>`;

// updateTripChart(); // <-- A√ëADE ESTA L√çNEA


            
            // fileResults.push({
            //     name: file.name,
            //     type: type, total:
            //     total, origin:
            //     tripInfo.origin || 'Not specified',
            //     destination: tripInfo.destination ||'Not specified',
            //     isValid: validationResult.isValid,
            //     validationDetails: validationResult.details,
            //     text: text });
            // updateResultsTable();
}
        

/**
 * --- VERSI√ìN 2: L√ìGICA DE VALIDACI√ìN CON SEGUNDA OPORTUNIDAD ---
 * Mantiene la l√≥gica estricta y a√±ade una flexible como respaldo.
 */
function validateTrip(tripInfo, type) {
    // --- CAMINO 1: L√ìGICA PARA IM√ÅGENES (sin cambios) ---
    if (type === 'image') {
        if (tripInfo.status === 'invalid') {
            return { isValid: false, details: 'Invalid: Classified as Food/Delivery by AI.', direction: null };
        }
        if (tripInfo.status === 'incomplete') {
            return { isValid: false, details: 'Incomplete receipt: Missing price or other data.', direction: null };
        }
        if (tripInfo.status === 'valid') {
            const destinationText = (tripInfo.destination || '').toLowerCase().trim();
            const validPatterns = [ /^43b/, /^43d/, /^mireka/ ];
            const isDestinationValidByPattern = validPatterns.some(pattern => pattern.test(destinationText));
            if (isDestinationValidByPattern) {
                // Determinar la direcci√≥n basada en el destino
                let direction = null;
                if (destinationText.includes('43b') || destinationText.includes('43d') || destinationText.includes('lauries')) {
                    direction = 'office-to-home'; // Si va a casa, es oficina a casa
                } else if (destinationText.includes('mireka') || destinationText.includes('havelock') || destinationText.includes('324')) {
                    direction = 'home-to-office'; // Si va a la oficina, es casa a oficina
                }
                return { isValid: true, details: 'Valid (matches a valid destination pattern)', direction: direction };
            }
            const staticValidDestinations = [ 'colombo 00400' ];
            const isDestinationValidByList = staticValidDestinations.some(validDest => destinationText.includes(validDest));
            if (isDestinationValidByList) {
                return { isValid: true, details: 'Valid (found in static list)', direction: null };
            }
            return { isValid: false, details: 'Invalid (Destination does not match any known pattern or list)', direction: null };
        }
    }

    // --- CAMINO 2: L√ìGICA PARA PDFs (CON SEGUNDA OPORTUNIDAD) ---
    if (type === 'pdf') {
        if (!tripInfo.origin || !tripInfo.destination) {
            return { isValid: false, details: 'Could not extract addresses from PDF.', direction: null };
        }

        const originText = tripInfo.origin.trim();
        const destinationText = tripInfo.destination.trim().toLowerCase();

        // --- PRIMERA VALIDACI√ìN (L√≥gica Estricta Actual) ---
        const isHome = (address) => address.startsWith('43');
        const isOffice = (address) => {
            const addr = address.toLowerCase();
            return addr.startsWith('324') || addr.includes('havelock') || addr.includes('mireka tower');
        };

        const isOriginHome = isHome(originText);
        const isDestinationOffice = isOffice(destinationText);
        const isOriginOffice = isOffice(originText);
        const isDestinationHome = isHome(destinationText);

        if (isOriginHome && isDestinationOffice) {
            return { isValid: true, details: 'Valid: Home -> Office route.', direction: 'home-to-office' };
        }
        if (isOriginOffice && isDestinationHome) {
            return { isValid: true, details: 'Valid: Office -> Home route.', direction: 'office-to-home' };
        }

        // --- SEGUNDA VALIDACI√ìN (L√≥gica Flexible por Palabras Clave) ---
        // Solo se ejecuta si la primera validaci√≥n fall√≥.
        const originZone = findZone(tripInfo.origin);
        const destinationZone = findZone(tripInfo.destination);

        if (originZone === 'home' && destinationZone === 'office') {
            return { isValid: true, details: 'Valid (by keyword match): Home -> Office route.', direction: 'home-to-office' };
        }
        if (originZone === 'office' && destinationZone === 'home') {
            return { isValid: true, details: 'Valid (by keyword match): Office -> Home route.', direction: 'office-to-home' };
        }

        // --- SI NADA FUNCIONA, ES INV√ÅLIDO ---
        return { isValid: false, details: 'Invalid: Addresses do not meet rules after multiple checks.', direction: null };
    }

    return { isValid: false, details: 'Invalid: Unknown file type or status from AI.', direction: null };
}
        
        function displayMap(fileName, direction) { 
            mapContainer.style.display = 'block'; 
            let mapTitle = document.querySelector('.map-title'); if (!mapTitle) { mapTitle = document.createElement('div'); mapTitle.className = 'map-title'; mapContainer.prepend(mapTitle); } 
            mapTitle.textContent = `Trip Map: ${fileName}`; 
            let originCoords, destCoords; if (direction === 'home-to-office') { originCoords = staticLocations.home; destCoords = staticLocations.office; } 
            else { originCoords = staticLocations.office; destCoords = staticLocations.home; } 
            if (!map) { map = L.map('map-container').setView([6.9, 79.86], 13); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map); } 
            map.eachLayer(layer => { if (layer instanceof L.Marker || layer instanceof L.Polyline) { map.removeLayer(layer); } }); 
            L.marker(originCoords).addTo(map).bindPopup('Origin').openPopup(); L.marker(destCoords).addTo(map).bindPopup('Destination'); 
            const lineColor = (direction === 'home-to-office') ? 'blue' : 'green'; const route = L.polyline([originCoords, destCoords], { color: lineColor, weight: 5, opacity: 0.7 }).addTo(map); 
            const group = new L.featureGroup([L.marker(originCoords), L.marker(destCoords)]); map.fitBounds(group.getBounds().pad(0.1)); 
            setTimeout(() => { map.invalidateSize(); }, 0); 
        }
        
        function updateResultsTable() {
            resultsContainer.style.display = 'block'; resultsBody.innerHTML = '';
            let totalSum = 0; let validCount = 0; let invalidCount = 0;
            fileResults.forEach((result, index) => {
                const row = document.createElement('tr');
                const nameCell = document.createElement('td'); nameCell.textContent = result.name;
                const typeCell = document.createElement('td'); typeCell.textContent = result.type === 'pdf' ? 'PDF' : 'Image';
                const originCell = document.createElement('td'); originCell.textContent = result.origin ? result.origin.substring(0, 50) + (result.origin.length > 50 ? '...' : '') : 'Not found';
                const destCell = document.createElement('td'); destCell.textContent = result.destination ? result.destination.substring(0, 50) + (result.destination.length > 50 ? '...' : '') : 'Not found';
                
                const totalCell = document.createElement('td'); 
                if (result.total && result.total !== '.' && result.total !== '.') {
                    totalCell.textContent = `${result.total} LKR`;
                } else {
                    totalCell.textContent = '0.00 LKR';
                }

                const validationCell = document.createElement('td');
                let badgeText, badgeClass;
                if (result.validationDetails.includes('Incomplete receipt')) {
                    badgeText = 'Incomplete';
                    badgeClass = 'valid-badge incomplete';
                } else if (result.isValid) {
                    badgeText = 'Valid';
                    badgeClass = 'valid-badge valid';
                } else {
                    badgeText = 'Invalid';
                    badgeClass = 'valid-badge invalid';
                }

                const validationBadge = document.createElement('span'); 
                validationBadge.className = badgeClass;
                validationBadge.textContent = badgeText; 
                validationCell.appendChild(validationBadge);
                
                const detailsDiv = document.createElement('div'); 
                detailsDiv.className = 'validation-details'; 
                detailsDiv.textContent = result.validationDetails || ''; 
                validationCell.appendChild(detailsDiv);
                
                const actionsCell = document.createElement('td'); 
                const viewBtn = document.createElement('button'); 
                viewBtn.className = 'view-details-btn'; 
                viewBtn.textContent = 'View details'; 
                viewBtn.onclick = function() { 
                    modalExtractedText.textContent = result.text; 
                    modal.style.display = 'block'; 
                }; 
                actionsCell.appendChild(viewBtn);
                
                row.appendChild(nameCell); row.appendChild(typeCell); row.appendChild(originCell); row.appendChild(destCell); 
                row.appendChild(totalCell); row.appendChild(validationCell); row.appendChild(actionsCell); 
                resultsBody.appendChild(row);
                
                if (result.total && result.total !== '.' && result.total !== '0.00' && result.isValid) {
                    totalSum += parseFloat(result.total.replace(',', '.'));
                }
                
                if (result.isValid) { 
                    validCount++; 
                } else { 
                    invalidCount++; 
                }
            });
            summary.innerHTML = `<p>Total files processed: ${fileResults.length}</p><p>Valid trips: ${validCount}</p><p>Invalid trips: ${invalidCount}</p><p>Total LKR sum (valid trips): ${totalSum.toFixed(2)} LKR</p>`;
        
            updateTripCalendar();//estamos actualizando esto, antes "updateTripChart();"


        }


    
            // --- L√ìGICA PARA EL GR√ÅFICO DE VIAJES ---

const viewChartBtn = document.getElementById('viewChartBtn');
const chartModal = document.getElementById('chartModal');
const closeChartBtn = document.getElementById('closeChartBtn');
let currentMonth = new Date().getMonth();
let currentYear = new Date().getFullYear();

viewChartBtn.addEventListener('click', () => {
    chartModal.style.display = 'block';
    updateTripCalendar();
});

closeChartBtn.onclick = () => chartModal.style.display = 'none';
window.onclick = (event) => { if (event.target == chartModal) chartModal.style.display = 'none'; };

/**
 * --- FUNCI√ìN PRINCIPAL: Actualiza y dibuja el calendario de viajes ---
 */
function updateTripCalendar() {
    // 1. Filtrar solo los PDFs v√°lidos
    const validPdfTrips = fileResults.filter(result => result.type === 'pdf' && result.isValid);
    
    // 2. Agrupar los viajes por d√≠a
    const tripsByDay = {};
    validPdfTrips.forEach(trip => {
        const day = trip.tripDate;
        if (!tripsByDay[day]) {
            tripsByDay[day] = [];
        }
        tripsByDay[day].push({
            direction: trip.direction,
            time: trip.tripTime
        });
    });
    
    // 3. Generar el calendario HTML
    const calendarContainer = document.getElementById('tripCalendar');
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"];
    
    // 4. Crear el encabezado del calendario
    const calendarHeader = document.createElement('div');
    calendarHeader.className = 'calendar-header';
    
    const prevMonthBtn = document.createElement('button');
    prevMonthBtn.className = 'calendar-nav';
    prevMonthBtn.textContent = 'Previous';
    prevMonthBtn.onclick = () => {
        currentMonth--;
        if (currentMonth < 0) {
            currentMonth = 11;
            currentYear--;
        }
        updateTripCalendar();
    };
    
    const monthYearLabel = document.createElement('h3');
    monthYearLabel.textContent = `${monthNames[currentMonth]} ${currentYear}`;
    monthYearLabel.style.textAlign = 'center';
    monthYearLabel.style.margin = '0';
    
    const nextMonthBtn = document.createElement('button');
    nextMonthBtn.className = 'calendar-nav';
    nextMonthBtn.textContent = 'Next';
    nextMonthBtn.onclick = () => {
        currentMonth++;
        if (currentMonth > 11) {
            currentMonth = 0;
            currentYear++;
        }
        updateTripCalendar();
    };
    
    calendarHeader.appendChild(prevMonthBtn);
    calendarHeader.appendChild(monthYearLabel);
    calendarHeader.appendChild(nextMonthBtn);
    
    // 5. Crear la tabla del calendario
    const calendarTable = document.createElement('table');
    calendarTable.className = 'calendar-table';
    
    // 6. Crear el encabezado de la tabla (d√≠as de la semana)
    const tableHeader = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    weekDays.forEach(day => {
        const th = document.createElement('th');
        th.textContent = day;
        headerRow.appendChild(th);
    });
    
    tableHeader.appendChild(headerRow);
    calendarTable.appendChild(tableHeader);
    
    // 7. Crear el cuerpo de la tabla
    const tableBody = document.createElement('tbody');
    
    // 8. Obtener el primer d√≠a del mes y el n√∫mero de d√≠as en el mes
    const firstDay = new Date(currentYear, currentMonth, 1).getDay();
    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
    
    // 9. Crear las filas del calendario
    let date = 1;
    for (let i = 0; i < 6; i++) {
        const row = document.createElement('tr');
        
        for (let j = 0; j < 7; j++) {
            const cell = document.createElement('td');
            
            if (i === 0 && j < firstDay) {
                // Celdas vac√≠as antes del primer d√≠a del mes
                cell.textContent = '';
            } else if (date > daysInMonth) {
                // Celdas vac√≠as despu√©s del √∫ltimo d√≠a del mes
                cell.textContent = '';
            } else {
                // Celdas con fechas
                const dayNumber = document.createElement('div');
                dayNumber.className = 'day-number';
                dayNumber.textContent = date;
                cell.appendChild(dayNumber);
                
                // Obtener la fecha en formato "d mes" (ej. "1 nov")
                const monthAbbrev = monthNames[currentMonth].substring(0, 3).toLowerCase();
                const dayKey = `${date} ${monthAbbrev}`;
                
                // Verificar si hay viajes para este d√≠a
                if (tripsByDay[dayKey]) {
                    const trips = tripsByDay[dayKey];
                    
                    // Crear indicadores para cada direcci√≥n
                    trips.forEach(trip => {
                        const indicator = document.createElement('div');
                        indicator.className = 'trip-indicator';
                        
                        if (trip.direction === 'home-to-office') {
                            indicator.classList.add('home-to-office');
                        } else if (trip.direction === 'office-to-home') {
                            indicator.classList.add('office-to-home');
                        }
                        
                        // A√±adir tooltip con la hora del viaje
                        if (trip.time) {
                            indicator.addEventListener('mouseenter', (e) => {
                                let formattedTime = trip.time;
                                // Asegurarse de que la hora tenga formato am/pm si no lo tiene
                                if (!formattedTime.toLowerCase().includes('am') && !formattedTime.toLowerCase().includes('pm')) {
                                    // Si no tiene am/pm, asumimos que es formato 24h y lo convertimos
                                    const timeParts = formattedTime.split(':');
                                    if (timeParts.length === 2) {
                                        const hour = parseInt(timeParts[0]);
                                        const minute = timeParts[1];
                                        const period = hour >= 12 ? 'pm' : 'am';
                                        const displayHour = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
                                        formattedTime = `${displayHour}:${minute}${period}`;
                                    }
                                }
                                tooltip.textContent = formattedTime;
                                tooltip.style.display = 'block';
                                tooltip.style.left = e.pageX + 10 + 'px';
                                tooltip.style.top = e.pageY - 30 + 'px';
                            });
                            
                            indicator.addEventListener('mouseleave', () => {
                                tooltip.style.display = 'none';
                            });
                        }
                        
                        cell.appendChild(indicator);
                    });
                } else {
                    // No hay viajes para este d√≠a
                    const indicator = document.createElement('div');
                    indicator.className = 'trip-indicator no-trip';
                    cell.appendChild(indicator);
                }
                
                date++;
            }
            
            row.appendChild(cell);
        }
        
        tableBody.appendChild(row);
        
        // Si ya hemos mostrado todos los d√≠as del mes, no necesitamos m√°s filas
        if (date > daysInMonth) {
            break;
        }
    }
    
    calendarTable.appendChild(tableBody);
    
    // 10. Limpiar y actualizar el contenedor del calendario
    calendarContainer.innerHTML = '';
    calendarContainer.appendChild(calendarHeader);
    calendarContainer.appendChild(calendarTable);
}



    </script>
</body>
</html>